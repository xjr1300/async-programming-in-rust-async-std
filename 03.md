# 3. チュートリアル: チャットの実装

チャット・サーバーを作成するよりも単純なことはないのではないでしょうか?
実はそうではなく、チャット・サーバーは、非同期プログラミングのすべての楽しみを紹介します。

どのようにサーバーは、同時並行にくらあんとの接続を処理するのでしょうか?

どのようにサーバーは、クライアントとの接続を処理するのでしょうか?

どのようにサーバーは、メッセージを配布するのでしょうか?

このチュートリアルは、`async-std`を使用して、チャット・サーバーを記述する方法を説明します。

また、あなたは[私たちのリポジトリ](https://github.com/async-rs/async-std/blob/master/examples/a-chat)でチュートリアルを確認できます。

## 3.1. 仕様と開始

### 仕様

チャットはTCPを介して単純なテキスト・プロトコルを使用します。
そのプロトコルは、`\n`で分離されたutf-8メッセージからなります。

クライアントはサーバーに接続して、最初の行でログインを送信します。
その後、クライアントは次の構文を使用して他のクライアントにメッセージを送信できます。

```text
login1, login2, ... longinN: message
```

それぞれ指定されたクライアントは`from login:message`メッセージを受信します。

起こり得るセッションは次のように見えるかもしれません。

```text
On Alice's computer:   |   On Bob's computer:

> alice                |   > bob
> bob: hello               < from alice: hello
                       |   > alice, bob: hi!
                           < from bob: hi!
< from bob: hi!        |
```

> 最初の行はログインである。
> 2行目では、アリスがボブにメッセージを送信して、ボブがアリスからのメッセージを受信している。
> 3行目では、ボブが、アリスと自分自身にメッセージを送信している。
> 4行目では、ボブが自分が送信したメッセージを受信している。
> 5行目では、アリスがボブからのメッセージを受信している。

チャット・サーバーで主に難しいのは、多くの同時接続を追跡し続けることです。
チャット・クライアントで主に難しいのは、同時に発信メッセージ、到着するメッセージとユーザーのタイピングを管理することです。

### 開始

新しいCargoプロジェクトを作成しましょう。

```sh
cargo new a-chat
cd a-chat
```

次の行を`Cargo.toml`に追加してください。

```toml
[dependencies]
future = "0.3.0"
async-std = "1"
```

## 3.2. 受信ループの記述

あるアドレスにTCPソケットをバインドして、接続の受付を開始する、サーバーの足場を実装しましょう。

まず最初に、要求されるインポートのボイラープレートを追加しましょう。

```rust
use async_std::net::{TcpListener, ToSocketAddrs};  //3
use async_std::prelude::*;  // 1
use async_std::task;  // 2

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;  // 4
```

1. `prelude`は、フューチャーとストリームが一緒に機能するために要求されるいくつかのトレイトを再エクスポートしています。
2. `task`モジュールは、おおまかに`std::thread`に対応していますが、タスクはより軽量です。
   シングル・スレッドは多くのタスクを実行できます。
3. ソケット型に、私たちは`async_std`の`TcpListener`を使用して、それはちょうど`std::net::TcpListener`のようですが、非ブロッキングで`async`APIを使用します。
4. この例において、私たちは包括的なエラー処理の実装を省略します。
   エラーを伝播させるために、私たちはボックス化したエラー・トレイト・オブジェクトを使用します。
   あなたは、stdlibに`From<&'_ str> for Box<dyn Error>`の実装があり、それは`?`演算子で文字列を使用できるようにすることを知っていますか?

> `From<&'_ str> for Box<dyn Error>`が実装されていれば、任意のライフタイムの文字列スライスを`Box<dyn Error>`に変換できる。

これで、私たちはサーバーの受付ループをを記述できます。

```rust
async fn accept_loop(addr: impl ToSocketAddrs) -> Result<()> {  // 1
    let listener = TcpListener::bind(addr).await?;  // 2
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.net().await {  // 3
        // TODO
    }

    Ok(())
}
```

1. 私たちは`accept_loop`関数を`async`でマークして、それは内部で私たちが`.await`構文を使用できるようにします。
2. `TcpListener::bind`呼び出しはフューチャーを返し、それを`Result`から抽出するために`.await`します。
   そして`TcpListener`を取得するために`?`します。
   `.await`と`?`が一緒に上手く動作していることに注意してください。
   これは`std::net::TcpListener`が機能する方法と同じですが、`.await`が追加されています。
   `std`のAPIのミラーリングが`async-std`の明確な設計ゴールです。
3. ここで、私たちはソケットへの到着を順番に処理したいため、`std`では次のようにします。

```rust
let listener: std::net::TcpListener = unimplemented!();
for stream in listener.incoming() {}
```

まだ言語で`async`なforループがサポートされていないため、残念ながら、まだこれは`async`で全く機能しません。
この理由で、私たちは、`while let Some(item) = iter.next().await`パターンを使用して、手動でループを実装しなければなりません。

最後に、メインを追加しましょう。

```rust
fn run -> Result<()> {
    let fut = accept_loop("127.0.0.1:8080");

    task::block_on(fut)
}
```

Rustにおいて認識しなくてはならない重要なことは、他の言語と違って、非同期関数の呼び出しはコードを実行しないことです。
非同期関数は、単にフューチャーを構築するのみで、フューチャーは不活性な状態マシンです。
非同期関数内でフューチャーの状態マシンを経由して、ステップを開始するために、あなたは`.await`を使用する必要があります。
同期関数内で、フューチャーを実行する方法は、フューチャーをエグゼキューターに手渡すことです。
この場合、カレント・スレッドでフューチャを実行して、フューチャーが終了するまでブロックするために、私たちは`task::block_on`を使用します。

## 3.3. メッセージの受信

プロトコルの受信部分を実装しましょう。
私たちは次を必要としています。

1. `\n`で到着した`TcpStream`を分割して、utf-8でバイトをデコードする。
2. ログインとして、最初の行を解釈する。
3. `login: message`として残りの行を解析する。

```rust
use async_std::io::BufReader;
use async_std::net::{TcpListener, TcpStream, ToSocketAddrs};

async fn accept_loop(addr: impl ToSocketAddrs) -> Result<()> {
    let listener = TcpListener::bind(addr).await?;
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        let _handle = task::spawn(connection_loop(stream));  // 1
    }

    Ok(())
}

async fn connection_loop(stream: TcpStream) -> Result<()> {
    let reader = BufReader::new(&stream);  // 2
    let mut lines = reader.lines();

    let name = match lines.next().await {  // 3
        None => Err("peer disconnected immediately")?,
        Some(line) => line?,
    };
    println!("name = {}", name);

    while let Some(line) = lines.next().await {  // 4
        let line = line?;
        let (dest, msg) = match line.find(':') {  // 5
            None => continue,
            Some(idx) => (&line[..idx], line[idx + 1..].trim()),
        };
        let dest: Vec<String> = dest
            .split(',')
            .map(|name| name.trim().to_string())
            .collect();
        let msg: String = msg.to_string();
    }

    Ok(())
}
```

1. 私たちは`task::spawn`関数を使用して、それぞれのクライアントに対して処理をする独立したタスクを生成します。
   それは、クライアントを受け付けた後、次を待つためにすぐに`connection_loop`（原文では`accept_loop`と記述されていたが誤り）を開始します。
   これは、イベント駆動アーキテクチャの主要な利点です。
   私たちは、多くのハードウェア・スレッドを消費せずに、同時に多くのクライアントを処理します。
2. 幸い、「バイト・ストリームを行に分割する」関数は、すでに実装されています。
   `.lines()`呼び出しは`String`のストリームを返します。
3. 私たちはログインとして最初の行を取得する。
4. 最後に、私たちはそれぞれの行をログイン先のリストとメッセージ自体を解析する。

### エラーの管理

上記実装(solution)の重大な問題の1つは、私たちが`connection_loop`内にエラーを正確に伝播させているにも関わらず、私たちは後でエラーを床に捨てるだけです!
`task::spawn`はすぐにエラーを返さず（それはできません、最初にそれは完了に向かってフューチャーを動かす必要があります）、後で単にそれは合流させられるだけです。
次のように、私たちは合流させるためにタスクを待機させることにより、それを修正できます。

```rust
let handle = task::spawn(connection_loop(stream));
handle.await?;
```

`.await`はクライアントが終了するまで待ち、`?`は結果を伝播させます。

しかし、この実装(solution)には2つの問題があります。
*最初に*、私たちはすぐにクライアントを待つため、単に私たちは1度に1つのクライアントだけしか処理できず、それは非同期の目的を完全に打ちのめします。
*2番目に*、もしクライアントがIOエラーに出会った場合、すぐにサーバー全体が終了します。
つまり、1つのピアのインターネット接続が不安定になると、チャット・ルーム全体がダウンします。

この場合、クライアント・エラーを処理する正しい方法は、それらのログを記録することで、他のクライアントの処理を継続します。
よって、このためのヘルパー関数を使用しましょう。

```rust
fn spawn_and_log_error<F>(fut: F) -> task::JoinHandle<()>
where
    F: Future<Output = Result<()>> + Send + 'static,
{
    task::spawn(async move {
        if let Err(e) = fut.await {
            eprintln!("{}", e);
        }
    })
}
```

## 3.4. メッセージの送信

現在、メッセージを送信する他の半分を実装する時間です。
送信を実装する最も明確な方法は、それぞれの`connection_loop`に他のそれぞれのクライアントの`TcpStream`の書き込みの半分へのアクセスを与えることです。
つまり、クライアントは直接受信者にメッセージを`.write_all`することができます。
しかし、これは良くないです。
もし、アリスが`bob: foo`を送信して、チャーリーが`bob: bar`を送信した場合、ボブは実際に`fobaor`を受信するかもしれません。
ソケットを経由してメッセージを送信することは、いくつかのシステム・コールを必要とするかも知れず、2つの同時並行な`.write_all`はお互いに干渉するかも知れません!

経験則として、ただ1つのタスクがお互いの`TcpStream`に書き込むべきです。
よって、チャネルを経由してメッセージを受け取り、ソケットにメッセージを書き込む`connection_writer_loop`タスクを作成しましょう。
このタスクはメッセージをシリアライズする地点になります。
もし、同時にアリスとチャーリーがボブに2つのメッセージを送信する場合、ボブはチャネルに到着した同じ順番でメッセージを確認できるでしょう。

```rust
use std::sync::Arc;

use futures::channel::mpsc; // 1
use futures::sink::SinkExt;

type Sender<T> = mpsc::UnboundedSender<T>;  // 2
type Receiver<T> = mpsc::UnboundedReceiver<T>;

async fn connection_writer_loop(
    mut messages: Receiver<String>,
    stream: Arc<TcpStream>,  // 3
) -> Result<()> {
    let mut stream = &*stream;
    while let Some(msg) = messages.next().await {
        stream.write_all(msg.as_bytes()).await?;
    }

    Ok(())
}
```

1. 私たちは`futures`クレートのチャネルを使用します。
2. 単純にするために、私たちは`unbounded`チャネルを使用しますが、このチュートリアルでバックプレッシャーについては議論しません。
3. `connection_loop`と`connection_writer_loop`は同じ`TcpStream`を共有しするため、`TcpStream`を`Arc`の中に入れる必要があります。
   `client`はストリームから読み込み、`connection_writer_loop`のみがストリームに書き込むため、ここで競合は発生しないことに注意してください。

## 3.5. リーダーとライターの接続

では、どのように`connection_loop`で読み込まれたメッセージが関連する`connection_writer_loop`に流れるようにするためにはどうすれば良いでしょうか?
私たちはなんとかして、行き先のチャネルを見つけることができるように、`peers: HashMap<String, Sender<String>>`を維持しなければなりません。
しかし、このマップは共有された可変な状態であるため、私たちはそれを`RwLock`で包み、もしクライアントがメッセージを受信すると同時に参加した場合に何が発生するべきかという難しい問題に答えます。

状態を簡単に推論するための1つのトリックは、アクター・モデルから得られます。
私たちは、`peers`マップを所有して、チャネルを使用して他のタスクとコミュニケーションする専用のブローカー・タスクを作成できます。
そのような「アクター」タスクの中に`peers`を隠すことにより、私たちはミューテックスを使用する必要を除き、シリアライズ地点を明確にします。
「ボブがアリスにメッセージを送信する」や「アリスが参加する」イベントの順番は、ブローカーのイベント・キュー内の対応するイベントの順番によって決定されます。

```rust
use std::collections::hash_map::{Entry, HashMap};

#[derive(Debug)]
enum Event {  // 1
    NewPeer {
        name: String,
        stream: Arc<TcpStream>,
    },
    Message {
        from: String,
        to: Vec<String>,
        msg: String,
    },
}

async fn broker_loop(mut events: Receiver<Event>) -> Result<()> {
    let mut peers: HashMap<String, Sender<String>> = HashMap::new();  // 2

    while let Some(event) = events.next().await {
        match event {
            Event::Message { from, to, msg } => {  // 3
                for addr in to {
                    if let Some(peer) = peers.get_mut(&addr) {
                        let msg = format!("from {}: {}\n", from, msg);
                        peer.send(msg).await?
                    }
                }
            }
            Event::NewPeer { name, stream } => match peers.entry(name) {
                Entry::Occupied(..) => (),
                Entry::Vacant(entry) => {
                    let (client_sender, client_receiver) = mpsc::unbounded();
                    entry.insert(client_sender);  // 4
                    spawn_and_log_error(connection_writer_loop(client_receiver, stream));
                }
            },
        }
    }

    Ok(())
}
```

1. ブローカー・タスクは、メッセージまたは新しいピアの2つのイベントを処理します。
2. ブローカーの内部状態は`HashMap`です。私たちは`Mutex`をここで使用しておらず、ブローカーのループのそれぞれのイテレーションで、現在のピアのセットが何であるかを、自信を持って言えることに注意してください。
3. メッセージを処理するために、私たちはそれぞれの宛先にチャネルを経由してメッセージを送信します。
4. 新しいピアを処理するために、最初に私たちはピア・マップに新しいピアを登録して・・・
5. ・・・、そして実際にソケットにメッセージを書き込む専用のタスクを生成します。

### [futures::chanel](https://docs.rs/futures/latest/futures/channel/index.html)

スレッドと同様に、同時並行タスクは、時々お互いに通信する必要がある。
このモジュールは、同時並行タスクがお互いに通信するための2つの基本的な抽象を含んでいる。

* [oneshot](https://docs.rs/futures/latest/futures/channel/oneshot/index.html): あるタスクから他のタスクに、1つの値を送信する方法
* [mpsc](https://docs.rs/futures/latest/futures/channel/mpsc/index.html): タスク間で値を送信する複数の生産者と1つの消費者で構成されるチャンネルで、標準ライブラリ内の同じような名前の構造体と類似

### [futures::chanel::mpsc](https://docs.rs/futures/latest/futures/channel/mpsc/index.html)

非同期タスク間で値を送信する、複数の生産者と1つの消費者のキューである。

`標準ライブラリ`と似たように、チャネルの作成は[Receiver](https://docs.rs/futures/latest/futures/channel/mpsc/struct.Receiver.html)と[Sender](https://docs.rs/futures/latest/futures/channel/mpsc/struct.Sender.html)ハンドルを提供する。
`Receiver`は[Stream](https://docs.rs/futures/latest/futures/futures_core/stream/trait.Stream.html)を実装しており、タスクがチャネルから出てきた値を読み込むことを可能にする。
もし、チャネルに読み込むメッセージがない場合、現在のタスクは新しい値が送信されたときに通知される（誰から通知されるのか?）。
`Sender`は`Sink`トレイトを実装しており、タスクがチャネル内にメッセージを送信することを可能にする。
もし、チャネルがいっぱいになっている場合、送信は拒否されて、タスクは追加の容量が利用できるようになったときに通知される（誰から通知されるのか?）。
言い換えれば、チャネルはバックプレッシャーを提供する。

> バックプレッシャー(`backpressure`)
>
> * 半二重制御のネットワーク機器などで用いられるフロー制御方式の1つ
> * 受信側が記憶装置の容量がいっぱいになることを避けるために、送信者の送信を抑制する手法
> * イーサーネットのハブやスイッチでは、受信したデータを一時保管するバッファが溢れそうになると、あえてコリジョン（衝突信号）を発生
> * 送信者は、コリジョンを検知して、データの送信を一時的に中断（ランダム時間経過した後に送信）
> * 送信者が一時的に中断している間に、ハブやスイッチはバッファを空ける

また、無制限な(`unbounded`)チャネルは、`unbounded`コンストラクタを使用して利用できる。

#### 切断

すべての`Sender`のハンドルがドロップされたとき、もはやチャネルに値を送信することはできない。
これはストリームの終了イベントとして考えられる。
そのような場合、[Receiver::poll_next](https://docs.rs/futures/latest/futures/futures_core/stream/trait.Stream.html#tymethod.poll_next)は`Ok(Ready(None))`を返す。

もし、`Receiver`のハンドルがドロップされた場合、もはやチャネルから出てくるメッセージが読まれることはない。
この場合、すべての将来の送信の試みは、エラーを返す。

#### 正しい終了（`Clean Shutdown`）

もし、`Receiver`が単純にドロップされた場合、チャネル内に処理されていないメッセージがまだ存在する可能性がある。
そのような場合、通常、「正しい(clean)」終了を実行することが望ましい。
これをするために、受信者は最初に`close`を呼び出し、それは、将来チャネル内にメッセージが送信されることを防ぐ。
そして、受信者は最後までチャネルを消費して、その時点で受信者はドロップできる。

```rust
/// 容量を制限したチャネルを作成する。
///
/// このチャネルは制限されているため、送信者が受信者を限られた量を上回ることを保証するバックプレッシャーを提供する。
/// チャネルの容量は、`buffer + 送信者の数`と等しくなります。
/// 言い換えれば、それぞれの送信者はチャネルの容量内で保証されたスロットを取得して、それに加えて、すべての送信者が
/// 利用できるバッファである「最初に来たものを、最初に処理する」スロットがある。
///
/// 返される`Receiverは`Stream`トレイトを実装している一方で、`Sender`は`Sink`を実装している。
pub fn futures::channel::mpsc::channel::channel<T>(buffer: usize) -> (Sender<T>, Receiver<T>)

/// 非同期タスク間で通信する容量の制限のないMPSCチャネルを作成する。
///
/// このチャネルでの`send`は、半分の受信者が切断していない限り、常に成功する。
/// もし受信者が背後で失敗指定場合、メッセーは任意にバッファされる。
/// 利用可能なシステム・メモリは暗黙的にチャネルを制限することに注意しなさい。
/// `unbounded`チャネルを使用することは、プロセスをメモリ不足にする可能性がある。
/// この場合、そのプロセスは中断させられる。
pub fn futures::channel::mpsc::channel::unbounded<T>() -> (UnboundedSender<T>, UnboundedReceiver<T>)
```

## 3.6. すべてを結合する

現時点で、私たちは十分に機能するチャットを得るために、ブローカーのみを実行する必要があります。

```rust
use std::collections::hash_map::{Entry, HashMap};
use std::sync::Arc;

use async_std::io::BufReader;
use async_std::net::{TcpListener, TcpStream, ToSocketAddrs};
use async_std::prelude::*;
use async_std::task;
use futures::channel::mpsc;
use futures::sink::SinkExt;

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

type Sender<T> = mpsc::UnboundedSender<T>;
type Receiver<T> = mpsc::UnboundedReceiver<T>;

fn main() -> Result<()> {
    task::block_on(accept_loop("127.0.0.1:8080"))
}

fn spawn_and_log_error<F>(fut: F) -> task::JoinHandle<()>
where
    F: Future<Output = Result<()>> + Send + 'static,
{
    task::spawn(async move {
        if let Err(e) = fut.await {
            eprintln!("{}", e);
        }
    })
}

async fn accept_loop(addr: impl ToSocketAddrs) -> Result<()> {
    let listener = TcpListener::bind(addr).await?;

    let (broker_sender, broker_receiver) = mpsc::unbounded();  // 1
    let _broker_handle = task::spawn(broker_loop(broker_receiver));
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!("Accepting from: {}", stream.peer_addr()?);
        spawn_and_log_error(connection_loop(broker_sender.clone(), stream));
    }

    Ok(())
}

async fn connection_loop(mut broker: Sender<Event>, stream: TcpStream) -> Result<()> {
    let stream = Arc::new(stream);  // 2
    let reader = BufReader::new(&*stream);
    let mut lines = reader.lines();

    let name = match lines.next().await {
        None => Err("peer disconnected immediately")?,
        Some(line) => line?,
    };
    broker
        .send(Event::NewPeer {
            name: name.clone(),
            stream: Arc::clone(&stream),
        })
        .await
        .unwrap();  // 3

    while let Some(line) = lines.next().await {
        let line = line?;
        let (dest, msg) = match line.find(':') {
            None => continue,
            Some(idx) => (&line[..idx], line[idx + 1..].trim()),
        };
        let dest: Vec<String> = dest
            .split(',')
            .map(|name| name.trim().to_string())
            .collect();
        let msg: String = msg.to_string();

        broker
            .send(Event::Message {
                from: name.clone(),
                to: dest,
                msg,
            })
            .await
            .unwrap();  // 4
    }

    Ok(())
}

async fn connection_writer_loop(
    mut messages: Receiver<String>,
    stream: Arc<TcpStream>,
) -> Result<()> {
    let mut stream = &*stream;
    while let Some(msg) = messages.next().await {
        stream.write_all(msg.as_bytes()).await?;
    }

    Ok(())
}

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc<TcpStream>,
    },
    Message {
        from: String,
        to: Vec<String>,
        msg: String,
    },
}

async fn broker_loop(mut events: Receiver<Event>) -> Result<()> {
    let mut peers: HashMap<String, Sender<String>> = HashMap::new();

    while let Some(event) = events.next().await {
        match event {
            Event::Message { from, to, msg } => {
                for addr in to {
                    if let Some(peer) = peers.get_mut(&addr) {
                        let msg = format!("from {}: {}\n", from, msg);
                        peer.send(msg).await?
                    }
                }
            }
            Event::NewPeer { name, stream } => match peers.entry(name) {
                Entry::Occupied(..) => (),
                Entry::Vacant(entry) => {
                    let (client_sender, client_receiver) = mpsc::unbounded();
                    entry.insert(client_sender);
                    spawn_and_log_error(connection_writer_loop(client_receiver, stream));
                }
            },
        }
    }

    Ok(())
}
```

1. `accept_loop`内で、私たちはブローカーのチャネルと`task`を作成します。
2. `connection_loop`内で、`connection_writer_loop`と`TcpStream`を共有するために、私たちは`Arc`の中に`TcpStream`を包む必要があります。
3. ログイン時に、私たちはブローカーに通知します。私たちが送信時に`.unwrap`していることに注意してください。
   ブローカーはすべてのクライアントよりも長生きしなければならず、もしそうでない場合、ブローカーはおそらくパニックしているため、私たちは十分にパニックをエスカレートできます。
4. 同様に、私たちは、ブローカーが生きていると想定して、ブローカに解析したメッセージを送信します。
