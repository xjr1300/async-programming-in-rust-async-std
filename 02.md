# 2. `async-std`を使用した非同期の概念

[Rustのフューチャー](https://en.wikipedia.org/wiki/Futures_and_promises)は難しいとの評判があります。
私たちはそのように考えていません。
私たちの意見では、それらは最も簡単な同時実行性の概念であり、直感的に説明できます。

しかし、そのような認識には十分な理由があります。
フューチャーは、常に混乱の原因となっている基本的な3つの概念があります。
それは、遅延計算と、非同期性、そして実行戦略の独立性です。

これらの概念は難しくありませんが、何か多くの人々が慣れていないものです。
その混乱の根底は、詳細を重視した多くの実装によってさらに増幅されます。
また、これらの実装のほとんどの説明は上級ユーザーを対象として、初心者にとって難しいです。
私たちは、理解するために簡単な基本要素と、親しみやすい概念の概要を提供することを試みます。

フューチャーは、コードの実行方法を抽象化した概念です。
フューチャー自身によって、フューチャーは何もしません。
これは、命令的な言語においては奇妙な概念で、普通、あることが、他のことの後にすぐに発生します。

では、どのようにフューチャーを実行するのでしょうか?
あなたが決めます!
フューチャーは、それらを*実行する*コードの断片なしで、何も実行しません。
この部分は*エグゼキューター*と呼ばれます。
*エグゼキューター*は、*いつ*そして*どのように*あなたのフューチャーを十個するか決定します。
`async-std::task`モジュールは、エグゼキューターのようなインターフェイスを、あなたに提供します。

まずは、少しだけやる気を起こすことから始めましょう。

## 2.1. フューチャー

Rustについて注目すべき点は、[恐れを知らぬ同時実行性](https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html)です。
それは、安全性を犠牲にすることなしに、同時に実行する権限を与えられるべきであるとうい概念です。
また、Rustが低水準の言語であるため、*特定の実装戦略を選択することなしに*、恐れを知らぬ同時実行性を提供することができます。
これは、もし私たちが異なる戦略を持つユーザー間でコードを共有する必要がある場合、*後で*選択できるように、戦略を抽象化しなければならないことを意味します。

フューチャーは、*計算*を抽象化します。
フューチャーは、「どこ」や「いつ」とは独立して、「何を」を記述します。
そのため、フューチャーは、私たちのシステムの部分によって実行されることができる行動可能なアクションとして、小さくコードを分割することを目指しています。
抽象化できる場所を見つけるために、物を計算することが何を意味するのかを確認しましょう。

### `Send`と`Sync`

幸運にも、同時実行Rustは、プログラムの同時実行部分間の共有を抽象化する、`Send`と`Sync`としてよく知られている効果的な2つの概念を持っています。
特に、`Send`と`Sync`トレイトは両方とも、同時実行作業の戦略を抽象化して、適切に構成されており、実装を規定していません。

簡単な説明を次に示します。

* `Send`は、ある計算内のデータを他の同時実行計算（レシーバーと呼びましょう）に渡すことを抽象化して、送信者側でデータにアクセスできなくします。
  多くのプログラミング言語において、一般的に、この戦略は実装されていますが、言語側からのサポートが欠けており、「アクセスを失う」振る舞いを自分自身で強制することを期待します。
  これはバグの定期的な発生源です。
  呼び出し側は送信する何かのハンドルを保持し続け、送信した後でそれらで作業するかもしれません。
  Rustはこの振る舞いを知っているものとしてマークすることにより、この問題を緩和します。
  （適切なマーカー・トレイトを実装することにより）型が`Send`になれるかそうでないか、それらを送信することを許可するか許可しないかすることができ、所有権と借用ルールが後続のアクセスを防止します。
* `Sync`は、プログラムの2つの同時実行部分間で共有されるデータです。
  これも他のよくあるパターンです。
  メモリの場所への書き込みや、他の当事者が書き込みを行っている間の読み取りは本質的に安全ではないため、このアクセスは同期を通じて緩和する必要があります([1](https://book.async.rs/concepts/futures#1))。
  例えば、ミューテックスやスピン・ロックのように、同時にメモリの同じ部分を使用しないで、。2つの当事者が同意するための、一般的な方法が多くあります。
  繰り返しになりますが、Rustは（安全を!）気にしない選択肢を与えてくれます。
  Rustは、同期が必要であることを表現することができる一方で、その「方法」については具体的ではありません。

私たちが*スレッド*のような単語を避けて、代わりに「計算」を選択したことに注意してください。
`Send`と`Sync`の完全な能力は、それらが*どのような*形であるかを知る負担を和らげることです。
実装時点では、あなたは目の前の型を共有する適切な方法を知ることだけです。
これは推論をローカルに保ち、後でその型を使用するユーザーがどのように実装するかに影響させません。

`Send`と`Sync`は興味深い方法で構成できますが、ここではそれは対象範囲外です。
あなたは[Rust Book](https://doc.rust-lang.org/stable/book/ch16-04-extensible-concurrency-sync-and-send.html)で例を見ることができます。

総括すると、Rustは、同時実行プログラミングの重要な属性を、安全に抽象化する能力を与えてくれます。
それは非常に軽量な方法で行われます。
言語自身は、`Send`と`Sync`の2つのマーカーを知るのみで、可能であれば、それ自身を継承することで私たちを少し助けてくれます。
残りはライブラリの関心事です。

### 計算の簡単な理解

計算は、[本](https://computationbook.com/)全体を書くための主題ですが、非常に単純化した見方で十分です。
決定に基づいて分岐できる構成可能な一連の操作は、成功するまで実行して、結果またはエラーを生成します。

### 計算の延期

上記で注意を促した通り、`Send`と`Sync`はデータに関するものです。
しかし、プログラムはデータに関してだけでなく、データの*計算*にも関することです。
そしてそれが[Futures](https://doc.rust-lang.org/std/future/trait.Future.htmlhttps://doc.rust-lang.org/std/future/trait.Future.html)がすることです。
私たちは、次のチャプターでそれがどのように機能するか詳細に確認します。
Futureを使用して英語で何を表現できるかを見てみましょう。
フューチャーは次の計画から進みます。

* Xを行う。
* もしXが成功した場合、Yを行う。

次に向かって。

* Xの実行を開始します。
* Xが成功したら、Yの実行を開始します。

導入における、「遅延計算」について話したことを覚えていますか?
それはこれだけです。
*今*、何を実行して決定するかをコンピューターに伝える代わりに、実行を開始することと、`Future`で発生する可能性のあるイベントに反応する方法を伝えます。

### 開始に向けて

簡単な関数の特別な戻り値について確認しましょう。

```rust
fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    Ok(contents)
}
```

あなたはこれをいつ呼ぶか完全な制御を持っているため、いつでもこれを呼び出すことができます。
しかし、ここに問題があります。
あなたがそれを呼び出す瞬間、最終的にそれが値を返すまで、制御を呼び出した関数に移動することです。
この戻り値は過去に関することであることに注意してください。
過去は欠点があり、すべての決定がすでにされているということです。
結果が可視であることには、利点があります。
私たちは、プログラムの過去の計算結果の覆いを外して、それで何をするかを決定するだけです。

しかし、私たちは、*計算*を抽象化して、他の誰かにそれを実行する方法を選択してもらうことが必要です。
それは、常に前の計算の結果を確認することと根本的に矛盾します。
よって、それを実行することなく、計算を*説明する*型を探しましょう。
再度、関数を確認してください。

```rust
fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    Ok(contents)
}
```

時間的に言えば、私たちは関数を呼び出す*前*、または関数が返った*後*にのみ行動を起こすことができます。
それは、それを実行している*間*、私たちから何かをする能力を奪うため、これは望ましくはありません。
同時なコードで実行するとき、これは最初に実行する間に、同時に実行するタスクを開始する能力を私たちから奪うでしょう（私たちは制御を手放したため）。

これは、私たちが[スレッド](https://en.wikipedia.org/wiki/Thread_)に手を伸ばす瞬間です。
しかし、スレッドはとても具体的な同時実行の基本要素で、私たちは抽象化を探していると言っていました。

私たちが探しているのは、将来、結果に向かって継続的に作業を実行することを表現するものです。
私たちがRustについて「何か」というときはいつでも、私たちはほとんど常にトレイトを意味します。
`Future`トレイトの不完全な定義から始めましょう。

```rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cs: &mut Context) -> Poll<Self::Output>;
}
```

それを詳細に確認して、次を確認します。

* それは`Output`を一般化しています。
* それは`poll`と呼ばれる関数を提供して、それは私たちが現在の計算の状態を確認できるようにします。
* （現時点では、`Pin`と`Context`を無視して、それらの高度な理解を必要としません。）

毎回の`poll()`の呼び出しは、次の2つのケースの1つの結果になります。

1. 計算が完了して、`poll`は[Poll::Ready](https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Ready)を返します。
2. 計算は実行を終了しておらす、それは[Poll::Pending](https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Pending)を返します。

これは、私たちが、まだ`Future`が未完了の作業を持っているか、最終的に終了して私たちに値を与えることができるか、外部から確認できるようにします。
最も単純（しかし効率的ではありません）な方法は、単にループ内で定期的にフューチャーをポーリングすることです。
最適化が可能で、これが優れたランタイムがすることです。
ケース1が発生した後で、再度`poll`を呼び出すことは、混乱した振る舞いになる可能性があります。
詳細は[Featuresドキュメント](https://doc.rust-lang.org/std/future/trait.Future.html)を参照してください。

> [Future Panic](https://doc.rust-lang.org/std/future/trait.Future.html#panics)
>
> 一度、フューチャーが完了したら（`poll`が`Ready`を返したら）、再びその`poll`メソッドを呼び出すことは、パニック、永遠にブロック。または他の種類の問題を引き起こす可能性があります。
> `Future`トレイトは、そのような呼び出しの効果に対する要件を設けていません。
> しかし、`poll`メソッドは`unsafe`でマークされていないため、次のRustの通常のルールが適用されます。
> フューチャの状態に関係なく、呼び出しは未定義動作を決して引き起こしてはなりません（メモリ破壊、`unsafe`関数の誤った使用）。

### Async

しばらくの間、Rustに`Future`トレイトが存在した一方で、`Future`トレイトはそれらを構築して記述することは不便でした。
このため、現在、Rustいは特別な構文`async`があります。
上記の例を`async-std`で実装すると、次のようになります。

```rust
async fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;

    Ok(contents)
}
```

驚くほど小さな違いですよね?
私たちは`async`で関数をラベルして、`.await`という2つの特別なコマンドを挿入しました。

この`async`関数は遅延計算を準備します。
この関数が呼び出されたとき、関数は、すぐに`io::Result<String>`を返す代わりに、`Future<Output = io.Result<String>>`を生成します。
（または、より正確に、`Future<Output = io::Result<String>>`を実装した型をあなたのために生成します。）

### `.await`は何をするのか?

`.await`接尾語は、その言葉通りに次の動作をします。
あなたがそれを使用した瞬間、コードは要求されたアクション（例えば、ファイルを開く、またはファイル内のすべてのデータを読み込むなど）が完了するまで待機します。
`.await?`は特別ではなく、単にそれは`.await`の結果に対する`?`演算子の応用です。
よって、何が初期コードの例で得られるでしょうか?
私たちはフューチャーを取得して、それらはすぐに待機するのでしょうか?

`.await`はマーカーとして機能します。
ここで、コードは`Future`の値を生成するために、`Future`を待機します。
どのようにフューチャーは終了するのでしょうか?
あなたは心配する必要はありません!
マーカーは、コードの断片を*実行*する責任のあるコンポーネント（通常、「ランタイム」と呼ばれます）が、計算が終了するまでに実行しなければならない他のすべての処理をできます。
`.await`は、バックグラウンドで実行していた操作が終了したときに、この場所に戻ってきます。
このプログラミング・スタイルが*イベント駆動プログラミング*とも呼ばれる理由です。
私たちは*何か*が発生するまで（例えばファイルが開かれるまで）待機して、そして反応します（読み込みを開始することにより）。

2つまたはより多くのこれらの関数が同時に実行されているとき、私たちのランタイム・システムは、現在実行中の*他のすべてのイベント*を処理して、待機時間を埋めることができます。

> ある関数が待機したときに他の関数を動作させることによって、関数の待機時間が無駄にならないようにしている。

### 結論

価値観に基づいて、*後で利用できる値に向かう作業*を表現する何かを探しました。
そこから、ポーリングの概念について説明しました。

`Future`は、値を表現するのではなく、*将来のある時点で値を生成する*能力を持っている、任意のデータ型です。
この実装は、ユース・ケースによって非常に多様で詳細になりますが、そのインターフェイスは単純です。

次は、実際にフューチャーを動かすために使用する`タスク`を説明します。

## 2.2. タスク

現在、私たちは、フューチャが何であるかを知り、それらを動かす必要があります!

`async-std`において、[task](https://docs.rs/async-std/latest/async_std/task/index.html)モジュールはこれをする責任があります。
その最も簡単な方法は、`block_on`関数を使用することです。

```rust
use async_std::fs::File;
use async_std::io;
use async_std::prelude::*;
use async_std::task;

async fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;

    Ok(contents)
}

fn main() {
    let reader_task = task::spawn(async {
        let result = read_file("Cargo.toml").await;
        match result {
            Ok(s) => println!("{}", s),
            Err(e) => println!("Error reading file: {:?}", e),
        }
    });
    println!("Started task!");
    task::block_on(reader_task);
    println!("Stopped task!");
}
```

これは、`async_std`に焼きつけられたランタイムに、ファイルを読み込むコードを実行するように要求されます。
内部から外務に1つずつ進みましょう。

```rust
async {
    let result = read_file("Cargo.toml").await;
    match result {
        Ok(s) => println!("{}", s),
        Err(e) => println!("Error reading file: {:?}", e),
    }
};
```

これは`async`ブロックです。
非同期ブロックは`async`関数を呼び出すために必要で、非同期ブロックは実行するすべての関係のある命令を含むことをコンパイラに命令します。
Rustにおいて、すべてのブロックは値を返し、そして`async`ブロックは`Future`の種類の値を返します。

しかし、興味深い部分に進みましょう。

```rust
task::spawn(async {});
```

`spawn`は`Future`を受け取り、`Task`の上でその実行を開始します。
`spawn`は`JoinHandle`を返します。
Rustにおけるフューチャーは、何か*冷たい*フューチャーと呼ばれています。
あなたはそれらを実行を開始する何かが必要です。
フューチャを実行するために、フューチャを実行または終了させ、メモリ内のどこに配置されているか、そして現在の状態は何かなど、追加の簿記が必要です。
この簿記の部分は、`Task`内で抽象化されています。

`Task`は`Thread`と似ていますが、いくつか小さな違いがあります。
タスクは、オペレーティング・システム・カーネルの代わりに、プログラムによってスケジュールされ、そしてタスクが待機する必要のある場所に出会った場合、そのプログラム自身はタスクを再度起動する責任があります。
私たちはそれについて後で少しお話しします。
また、`async_std`のタスクは、ちょうどスレッドのように名前とIDを持つことができます。

現在のところ、一旦、あなたがタスクを生み出したら、タスクはバックグラウンドで動作し続けることを知っていれば十分です。
`JoinHandle`自体は、タスクが最後まで実行されると終了するフューチャーです。
`スレッド`と`join`関数と同様に、私たちはプログラム（具体的には呼び出したスレッド）を*ブロック*するために、ハンドルの`block_on`を呼び出すことができ、そして、終了するまでそれを待ちます。

### `async_std`におけるタスク

`async_std`におけるタスクは、抽象化の核となる1つです。
Rustのスレッドと同様に、タスクは概念そのままを超えた、任意の実用的な機能を提供します。
`タスク`はランタイムと関係がありますが、タスク自体はそれら自身で分離しています。
`async_std`のタスクは、望ましい足をを複数持っています。

* タスクは1つの単一な割り当てで配置されます。(They are allocated in one single allocation)。
* すべてのタスクは*バックチャネル*を持ち、それは`JoinHandle`を経由して結果またはエラーを生成タスクに電波させます。
* タスクはデバッグするために便利なメタデータを持ちます。
* タスクはタスクのローカル・ストレージをサポートします。(They support task local storage)

`async_std`のタスクAPIは、背後のランタイムの準備と解体を処理して、が明示的に開始されたランタイムに依存しません。

### ブロッキング

`タスク`は、潜在的に実行スレッドを共有することによって、同時で動作することを想定されています。
これは、`std::thread::sleep`のような*オペレーティング・システム・スレッド*をブロックする操作や、Rustの`標準`ライブラリのIO関数が、*このスレッドを共有するすべてのタスクの実行を停止*することを意味します。

> タスクは実行スレッドを共有するため、タスクの処理内にブロックを要求するような処理がある場合、スレッドを共有しているタスクすべてが停止する。
> よって、ブロックするような処理を非同期にすることで、現在のタスクがブロックしても、他のタスクに処理を譲ることで、他のタスクを実行できるようになる。

他のライブラリ（データベース・ドライバのような）は同様の振る舞いを持ちます。
*カレント・スレッドのブロック*すること自体は悪い振る舞いではなく、`async-std`の同時実行処理とうまく混ぜ合わせることができないだけであることに注意してください。
基本的に、次は絶対にしないでください。

```rust
fn main() {
    task::block_on(async {
      // これはstd::fsで、ブロックします。
      std::fs::read_to_string("test_file");
    })
}
```

もし、操作する種類を混ぜ合わせる必要がある場合、異なる`スレッド`にそのようなブロックする操作を移動することを検討してください。

### エラーとパニック

タスクは普通のパターンでエラーを報告します。
もしタスクが失敗する可能性がある場合、タスクの`Output`は`Result<T, E>`のような種であるべきです。

`panic`の場合、振る舞いは、`panic`に対応する合理的な部分があるかどうかによって異なります。
もし、そうでない場合、プログラムは中止されます。

実際に、それは`block_on`がブロッキングしているコンポーネントに`panic`を伝播することを意味します。

```rust
fn main() {
    task::block_on(async {
        panic!("test");
    });
}
```

```text
thread 'main' panicked at examples/panic.rs:3:9:
test
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

> エラー・メッセージの最初の行の、`thread 'main'`に注目すること。
> これは`main`（ブロッキングしているコンポーネント）にパニックが伝播していることを示している。

パニックしている間、生成されたタスクは中止されます。

```rust
task::spawn(async {
    panic!("test");
});

task::block_on(async {
    task::sleep(Duration::from_milles(10_000)).await;
});
```

```text
thread 'async-task-driver' panicked at 'test', examples/panic.rs:8:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
Aborted (core dumped)
```

> 実際には、上記のように`task::sleep`は中止されなかった。
> 実際には、最初のタスクがパニックで中止され、次のタスクの影響で10秒後にプロンプトが表示された。
> `echo $?`を実行すると`0`が返された。
> 上記の前の例(パニックするタスクだけを実行するプログラム)では、`echo $?`で`101`が返される。
> Rustはプログラムがパニックしたとき、終了コードを`101`に設定する。

```text
thread 'async-std/runtime' panicked at examples/panic_and_abort_task.rs:7:9:
test
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

最初、これは奇妙に見えますが、他の選択肢は、生成されたタスク内で静かにパニックを無視することです。
現在の振る舞いは、生成されたタスク内でパニックを補足して、独自の振る舞いで反応することで変更できます。
これは、ユーザーにパニック処理戦略の選択を与えます。

### 結論

`async_std`には`std::tread`に似たAPIと機能する便利な`Task`型がついています。
`Task`型は構造化され定義された方法でエラーとパニックの振る舞いをカバーします。

タスクは分離した同時実行ユニットで、通常、それらは会話することが必要です。
そこで`Stream`が登場します。

## 2.3. TODO: 非同期読み込みと書き込みAsync read/write

## 2.4. TODO: ストリームとチャネル
