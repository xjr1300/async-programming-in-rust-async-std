# 1. async-stdの導入

この本は、`async-std`の高度なドキュメントとして、またこの本を通じてRustで非同期プログラミングを学習する方法を提供しています。
そのため、この本は`async-std`のAPIと、`async-std`が提供するタスク・モデルに焦点を当てています。

Rustプロジェクトは、[Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)と呼ばれる、プロジェクト独自の非同期プログラミングに関する本を提供していることの注意してください。
私たちは、Rustプロジェクトが提供している本を、この本と合わせて読むことを高くお勧めします。
Rustプロジェクトが提供している本は、非同期プログラミングについて、異なり、より広い視点を提供しています。

## 1.1. `async-std`へようこそ

`async-std`が[サポートしているライブラリ](https://github.com/async-rs)と合わせて、`async-std`は、非同期プログラミングを容易にするライブラリです(a library making your life in async programming easier)。
`async-std`は、`async-std`を使用するライブラリとアプリケーションに対する、基礎的な実装を提供しています。
`async-std`という名前は、このライブラリを反映ていています。
`async-std`は、可能な限りRustの主要な標準ライブラリに近づくように構築されており、すべてのコンポーネントが非同期対応したコンポーネントに置き換えられます。

`async-std`は、ファイル・システム操作、ネットワーク操作、そしてタイマーのような同時実行の基本など、すべての重要な基本要素へのインターフェイスを提供しています。
また、`async-std`は、Rust標準ライブラリ内で見つけることができる`thread`モジュールに似たモデルで`task`を公開しています。
しかし、`async-std`は、I/Oの基本要素だけでなく、`Mutex`のような基本要素の`async/await`互換バージョンも提供しています。

## 1.2. `std::future`と`future-rs`

Rustは、一般的に`Future`として参照される2種類の型があります。

* 1つ目は、Rustの[標準ライブラリ](https://doc.rust-lang.org/std/future/trait.Future.html)にある`std::future::Future`です。
* 2つ目は、[future-rsクレート](https://docs.rs/futures/0.3/futures/prelude/trait.Future.html)にある`futures::future::Future`です。

[futures-rs](https://docs.rs/futures/0.3/futures/prelude/trait.Future.html)クレートで定義されているフューチャーは、`Future`型のオリジナルな実装です。
`async/await`構文を有効にするために、`Future`トレイトの核は、Rustの標準ライブラリ内に移動され、`std::future::Future`になりました。
ある意味で、`std::future::Future`は、`futures::future::Future`の最小限のサブセットとして見なすことができます。

`std::future::Future`と`futures::future::Future`の違いを理解することと、`async-std`が採用したそれらへのアプローチを理解することは、非常に重要です。
`std::future::Future`自体は、それに対して`.await`を呼び出すことをのぞいて、ユーザーとして相互作用する必要があるものではありません。
`std::future::Future`の内部動作は、`Future`を実装している人々にとって興味深いものです。
間違いなく、これはとても便利です!
`Future`自体に定義されているほとんどの機能は、[FutureExt](https://docs.rs/futures/0.3/futures/future/trait.FutureExt.html)と呼ばれる拡張トレイトに移動されています。
この情報から、あなたは、`futures`ライブラリが、Rustの非同期機能のコアの拡張として提供されていることを類推できるかもしれません。
`futures`と同じ伝承で、`async-std`は、コアである`std::future::Future`型を再エクスポートしています。
あなたは、`Cargo.toml`に追加して、`FutureExt`をインポートすることによって、実際に`futures`クレートによる拡張の提供を受け入れることができます。

### インターフェイスと安定性

`async-std`は、Rust標準ライブラリのレベルで、安定的で信頼性のあるライブラリになることを目標としています。
これは、私たちは、私たちのインターフェイスとして`futures`ライブラリに依存しないことを意味します。
それでも、私たちは、`futures-rs`がもたらす利便性を気に入っている多くのユーザーに感謝しています。
この理由で、`async-std`は、その型としてすべての`futures`トレイトを実装しています。

幸運にも、上記アプローチは、完全な柔軟性を提供します。
そみ、あなたが安定性にとても気に掛けるのであれば、単にあなたは`async-std`を使用できます。
もし、あなたが`futures`ライブラリのインターフェイスが好みであれば、それらをリンクします。
両方の利用は、非常に良いです。

#### `async_std::future`

任意の種類のフューチャーと一緒に機能させるために私たちが重要と見みなす、いくつかのサポート関数があります。
これらは、`async_std::future`モジュール内に見つけることができ、私たちの安定性の保証の対象となります。

### ストリームと`Read`/`Write`/`Seek`/`BufRead`トレイト

Rustコンパイラの制限のために、それらは現在`async-std`内で実装されていますが、ユーザー自身によって実装することはできません。

## 1.3. 安定性とセマンティック・バージョニング(SemVer)

`async-std`は、<https://semver.org/>に従っています。

簡潔に言えば、私たちは`MAJOR.MINOR.PATCH`のように、私たちのソフトウェアをバージョニングしています。
私たちは、次のようにバージョンを増やします。

* `MAJOR`バージョンは、互換性のないAPIの変更があるときです。
* `MINOR`バージョンは、下位互換性のある方法で機能が導入されるときです。
* `PATCH`バージョンは、下位互換性のあるバグ修正をしたときです。

### フューチャーの例外

`async-std`は、次の概念の`async-std`独自の実装を使用します。

* `Read`
* `Write`
* `Seek`
* `BufRead`
* `Stream`

エコシステムと統合するために、すべての型は`futures-rs`ライブラリと対応するインターフェイスの実装を持つこれらのトレイトを実装しています。
私たちのセマンティック・バージョニングの保証は、それらのインターフェイスの使用に拡張しないことに注意してください。
私たちは、これらが控えめに、足並みを揃えて更新されることを規定しています。

### 最小バージョン方針

現在の暫定的な方針は、これらのクレートを使用する最小のRustバージョンが、マイナー・バージョン・アップデートで増やすことができることです。
例えば、もし`async-std` 1.0がRust 1.37.0を溶融するのであれば、すべての値zの`async-std` 1.0.zは、Rust 1.37.0またはそれ以降を要求します。
y > 0な1.yは、Rustの最新の最小バージョンを要求するかもしれません。

一般的に、このクレートは、サポートされるRustの最小バージョンに対して保守的になります。
ただし、`async/await`は新しい機能であるため、最初、私たちは測定されたペースで変更を追跡します。

### セキュリティの修正

セキュリティの修正は、すべての*サポートされている*メジャー・バージョンについて、このライブラリの*すべての*マイナー・ブランチに適用されます。
このポリシーは将来変更されるかもしれませんが、その場合、少なくとも*3ヶ月*前に通知します。

### クレジット

このポリシーは、[BurntSushiのregexクレート](https://github.com/rust-lang/regex#minimum-rust-version-policy)に基づいています。
